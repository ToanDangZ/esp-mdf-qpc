/*$file${components::test::.::test.c} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*
* Model: get-started.qm
* File:  ${components::test::.::test.c}
*
* This code has been generated by QM 4.5.1 (https://www.state-machine.com/qm).
* DO NOT EDIT THIS FILE MANUALLY. All your changes will be lost.
*
* This code is covered by the following QP license:
* License #   : QPC-ANY-171208A
* Issued to   : Zimplistic Private Limited
* Framework(s): qpc
* Support ends: 2019-12-08
* Product(s)  :
* Any product of Zimplistic Private Limited
*/
/*$endhead${components::test::.::test.c} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
#include "qpc.h"
#include "signalList.h"
#include "priorityList.h"
#include "test.h"

Q_DEFINE_THIS_FILE

/*$declare${components::test::test} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${components::test::test} ................................................*/
typedef struct {
/* protected: */
    QActive super;

/* public: */
    QTimeEvt tickTimeEvt;
} test;

/* protected: */
static QState test_initial(test * const me, QEvt const * const e);
static QState test_TOP(test * const me, QEvt const * const e);
/*$enddecl${components::test::test} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/* Local Object */
static test l_test;
/* FreeRTOS stack for AO */
static StackType_t testStack[1024];
/* AO Queue */
QEvt const * l_testQSto[64];
/* Global Oject: opaque pointer to test AO */
QActive * const AO_test = &l_test.super;

/*$skip${QP_VERSION} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/* Check for the minimum required QP version */
#if (QP_VERSION < 650U) || (QP_VERSION != ((QP_RELEASE^4294967295U) % 0x3E8U))
#error qpc version 6.5.0 or higher required
#endif
/*$endskip${QP_VERSION} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
/*$define${components::test::TEST_ctor} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${components::test::TEST_ctor} ...........................................*/
void TEST_ctor(void) {
    static uint8_t bInitDone = (uint8_t)0;
    char taskName[16];
    test *me;

    if(bInitDone == (uint8_t)0) {
        me = &l_test;
        /* Call constructor */
        QActive_ctor(&me->super, Q_STATE_CAST(&test_initial));
        /* Call orthogonal Component constructor */

        /* Call Timer Constructor */
        QTimeEvt_ctorX(&me->tickTimeEvt, &me->super, TICK_SIG, 0U);

        /* Initialize members */

        /* Start active object */
        sprintf(taskName, "AO_test");
        QActive_setAttr(AO_test, TASK_NAME_ATTR, taskName);
        QACTIVE_START(
            AO_test,
            PRIORITY_TEST,
            l_testQSto,
            Q_DIM(l_testQSto),
            testStack,
            sizeof(testStack),
            (QEvt *)0);

        bInitDone = (uint8_t)1;
    }
}
/*$enddef${components::test::TEST_ctor} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/

/*$define${components::test::test} vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv*/
/*${components::test::test} ................................................*/
/*${components::test::test::SM} ............................................*/
static QState test_initial(test * const me, QEvt const * const e) {
    /*${components::test::test::SM::initial} */
    /* Arm Timer for periodic generation of events */
    QTimeEvt_armX(&me->tickTimeEvt, TEST_TICK_INTERVAL_MS, TEST_TICK_INTERVAL_MS);
    return Q_TRAN(&test_TOP);
}
/*${components::test::test::SM::TOP} .......................................*/
static QState test_TOP(test * const me, QEvt const * const e) {
    QState status_;
    switch (e->sig) {
        /*${components::test::test::SM::TOP::TICK} */
        case TICK_SIG: {
            /* Test */
            uint8_t cpuId = xPortGetCoreID();
            #if 0
            QS_BEGIN(QS_USER0, &me->super);
                QS_U8(1, cpuId);
                QS_STR("AO_test: Tick Event");
            QS_END();
            #else
            printf("CPU%d: AO_test Tick Event\n", cpuId);
            #endif
            status_ = Q_HANDLED();
            break;
        }
        default: {
            status_ = Q_SUPER(&QHsm_top);
            break;
        }
    }
    return status_;
}
/*$enddef${components::test::test} ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^*/
